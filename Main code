%% =========== SINE-GORDON KINK DYNAMICS PROJECT ============
clc; clear; close all;

%% Setup the Grid
N = 400; 
L = 50;

x = linspace(-L, L, N)';
dx = x(2) - x(1);

%% Options
solver_Type = "ode113";        % "ode113", "rk4"
initial_Conditions = "single"; % "single", "moving", "collision"
boundary_Conditions = "neumann"; % "neumann", "dirichlet"
show_Energy = false;
show_Phase_Diagram = false;
speed = 0.3;

%% Initial Conditions (Sine-Gordon)
switch initial_Conditions
    case "single"
        % Static sine-Gordon kink
        phi0 = 4*atan(exp(x));
        v0   = zeros(N,1);

    case "moving"
        % Moving sine-Gordon kink
        x0 = -10;
        gamma = 1/sqrt(1-speed^2);
        z = gamma*(x - x0);
        phi0 = 4*atan(exp(z));
        v0 = -4*gamma*speed * exp(z) ./ (1 + exp(2*z));

    case "collision"
        % Kinkâ€“antikink collision
        x0 = 5;
        gamma = 1/sqrt(1-speed^2);

        z1 = gamma*(x + x0);
        z2 = gamma*(x - x0);

        phi0 = 4*atan(exp(z1)) - 4*atan(exp(z2));
        v0 = -4*gamma*speed * ( ...
            exp(z1)./(1+exp(2*z1)) + exp(z2)./(1+exp(2*z2)) );
end

%% Potential (Sine-Gordon)
U   = @(phi) (1 - cos(phi));
U_p = @(phi) sin(phi);

%% Time parameters
Tfinal = 100;
dt = 0.01;
tspan = [0 Tfinal];

%% Initial state vector
y0 = [phi0; v0];

%% Laplacian
Laplacian = build_laplacian(N, dx, boundary_Conditions);

%% Solve PDE
switch solver_Type
    case "ode113"
        [T, Y] = ode113(@(t,y) kink_rhs(y, Laplacian, U_p), tspan, y0);
        state = Y(:, 1:N)';

    case "rk4"
        Nt = floor(Tfinal/dt) + 1;
        y = y0;
        state = zeros(N, Nt);
        state(:,1) = phi0;

        for k = 2:Nt
            k1 = kink_rhs(y, Laplacian, U_p);
            k2 = kink_rhs(y + 0.5*dt*k1, Laplacian, U_p);
            k3 = kink_rhs(y + 0.5*dt*k2, Laplacian, U_p);
            k4 = kink_rhs(y + dt*k3, Laplacian, U_p);
            y = y + dt*(k1 + 2*k2 + 2*k3 + k4)/6;
            state(:,k) = y(1:N);
        end
        T = linspace(0, Tfinal, Nt);
end

%% Plot snapshots
figure;
plot(x, state(:,1), 'LineWidth', 2); hold on;
plot(x, state(:,round(end/4)), 'LineWidth', 2);
plot(x, state(:,round(end/2)), 'LineWidth', 2);
plot(x, state(:,round(3*end/4)), 'LineWidth', 2);
plot(x, state(:,end), 'LineWidth', 2);
xlabel('x','Interpreter','latex');
ylabel('$\phi$','Interpreter','latex');
title('Sine-Gordon field snapshots');
legend('$t=0$','$t=T/4$','$t=T/2$','$t=3T/4$','$t=T$','Interpreter','latex');
grid on; set(gca,'fontsize',14);

%% Phase diagram at x=0
if show_Phase_Diagram
    [~, idx0] = min(abs(x));
    figure;
    plot(Y(:,idx0), Y(:,N+idx0), 'LineWidth', 2);
    xlabel('$\phi(0,t)$','Interpreter','latex');
    ylabel('$\phi_t(0,t)$','Interpreter','latex');
    title('Phase-space at x=0');
    grid on;
end

%% Animation
filename = 'sine_gordon_kink.mp4';
video = VideoWriter(filename,'MPEG-4');
video.FrameRate = 10;
open(video);

figure;
step = max(1,floor(length(T)/200));

for n = 1:step:length(T)
    plot(x, state(:,n),'LineWidth',2);
    ylim([-1 7]); xlim([-20 20]);
    xlabel('x','Interpreter','latex');
    ylabel('$\phi$','Interpreter','latex');
    title(sprintf('Sine-Gordon kink, t = %.2f', T(n)));
    grid on;
    frame = getframe(gcf);
    writeVideo(video, frame);
end
close(video);

disp(['Saved animation as ', filename]);

%% ================= FUNCTIONS =================

function dydt = kink_rhs(y, Laplacian, U_p)
    N = length(y)/2;
    phi = y(1:N);
    v   = y(N+1:end);

    phi_t = v;
    v_t   = Laplacian*phi - U_p(phi);

    dydt = [phi_t; v_t];
end

function Lap = build_laplacian(N, dx, BC)
    e = ones(N,1);
    Lap = spdiags([e -2*e e], -1:1, N, N);

    switch lower(BC)
        case "neumann"
            Lap(1,:) = 0;  Lap(1,1) = -2; Lap(1,2) = 2;
            Lap(end,:) = 0; Lap(end,end) = -2; Lap(end,end-1) = 2;
        case "dirichlet"
            Lap(1,:) = 0; Lap(1,1) = 1;
            Lap(end,:) = 0; Lap(end,end) = 1;
    end

    Lap = Lap / dx^2;
end

function E = energy_density(phi, v, dx, U)
    dphi = zeros(size(phi));
    dphi(2:end-1) = (phi(3:end)-phi(1:end-2))/(2*dx);
    E = 0.5*v.^2 + 0.5*dphi.^2 + U(phi);
end
